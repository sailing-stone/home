import{r as g}from"./react-BXtthtrb.js";var S=new Map,h=new WeakMap,A=0,x=void 0;function M(e){return e?(h.has(e)||(A+=1,h.set(e,A.toString())),h.get(e)):"0"}function O(e){return Object.keys(e).sort().filter(t=>e[t]!==void 0).map(t=>`${t}_${t==="root"?M(e.root):e[t]}`).toString()}function T(e){const t=O(e);let n=S.get(t);if(!n){const f=new Map;let o;const i=new IntersectionObserver(s=>{s.forEach(r=>{var u;const v=r.isIntersecting&&o.some(c=>r.intersectionRatio>=c);e.trackVisibility&&typeof r.isVisible>"u"&&(r.isVisible=v),(u=f.get(r.target))==null||u.forEach(c=>{c(v,r)})})},e);o=i.thresholds||(Array.isArray(e.threshold)?e.threshold:[e.threshold||0]),n={id:t,observer:i,elements:f},S.set(t,n)}return n}function _(e,t,n={},f=x){if(typeof window.IntersectionObserver>"u"&&f!==void 0){const u=e.getBoundingClientRect();return t(f,{isIntersecting:f,target:e,intersectionRatio:typeof n.threshold=="number"?n.threshold:0,time:0,boundingClientRect:u,intersectionRect:u,rootBounds:u}),()=>{}}const{id:o,observer:i,elements:s}=T(n),r=s.get(e)||[];return s.has(e)||s.set(e,r),r.push(t),i.observe(e),function(){r.splice(r.indexOf(t),1),r.length===0&&(s.delete(e),i.unobserve(e)),s.size===0&&(i.disconnect(),S.delete(o))}}function $({threshold:e,delay:t,trackVisibility:n,rootMargin:f,root:o,triggerOnce:i,skip:s,initialInView:r,fallbackInView:u,onChange:v}={}){var c;const[b,V]=g.useState(null),l=g.useRef(v),[R,p]=g.useState({inView:!!r,entry:void 0});l.current=v,g.useEffect(()=>{if(s||!b)return;let a;return a=_(b,(E,I)=>{p({inView:E,entry:I}),l.current&&l.current(E,I),I.isIntersecting&&i&&a&&(a(),a=void 0)},{root:o,rootMargin:f,threshold:e,trackVisibility:n,delay:t},u),()=>{a&&a()}},[Array.isArray(e)?e.toString():e,b,o,f,i,s,n,u,t]);const w=(c=R.entry)==null?void 0:c.target,y=g.useRef(void 0);!b&&w&&!i&&!s&&y.current!==w&&(y.current=w,p({inView:!!r,entry:void 0}));const d=[V,R.inView,R.entry];return d.ref=d[0],d.inView=d[1],d.entry=d[2],d}export{$ as u};
